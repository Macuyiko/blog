<!DOCTYPE html>

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width" />

	<title>Rigging Match 3 Games</title>

	<link rel="stylesheet" href="//blog.macuyiko.com/theme/css/normalize.css" />
	<link rel="stylesheet" href="//blog.macuyiko.com/theme/css/foundation.min.css" />
	<link rel="stylesheet" href="//blog.macuyiko.com/theme/css/style.css" />
	<link rel="stylesheet" href="//blog.macuyiko.com/theme/css/pygments.css" />
	<script src="//blog.macuyiko.com/theme/js/jquery-3.4.1.min.js"></script>
	<link rel="preconnect" href="https://fonts.gstatic.com">
	<link href="https://fonts.googleapis.com/css?family=Bitter:400,700|Source+Code+Pro&display=swap" rel="stylesheet">


	<script type="text/javascript">
		var waitForFinalEvent = (function () {
			var timers = {};
			return function (callback, ms, uniqueId) {
				if (!uniqueId) uniqueId = "_";
				if (timers[uniqueId]) clearTimeout(timers[uniqueId]);
				timers[uniqueId] = setTimeout(callback, ms);
			};
		})();
		var insertCaptions = function () {
			$('#articlecontainer .caption').remove();
			var width = $(window).width();
			var onmobile = width < 1400; //>
			var capclass = onmobile ? 'caption-below' : 'caption-aside';
			$.each($('#articlecontainer img'), function (index, value) {
				if ($(value).attr('alt') != undefined) {
					var elem = $('<div class="caption ' + capclass + '">' + $(value).attr('alt') + '</div>');
					if (onmobile) elem.insertAfter(value);
					else elem.insertBefore(value);
				}
			});
		};
		$(function () {
			$(window).resize(function () {
				waitForFinalEvent(function () {
					insertCaptions();
				}, 500, "window.resize");
			});
			insertCaptions();
		});
	</script>
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-60406-11']);
		_gaq.push(['_trackPageview']);

		(function () {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>
</head>

<body>

	<nav>
		<div class="top-bar large-12 columns">
			<h1><a href="//blog.macuyiko.com/">Bed Against The Wall</a></h1>
		</div>
	</nav>


	<div class="row contentwrapper">
		<div class="row">
<div id="articlecontainer" class="large-9 columns large-centered">
	<article>
		<header>
			<div class="article-info">Wed 04 November 2020, by Seppe "Macuyiko" vanden Broucke</div>
			<div class="article-title"><a href="//blog.macuyiko.com/post/2020/rigging-match-3-games.html" rel="bookmark"
			title="Permalink to Rigging Match 3 Games">Rigging Match 3&nbsp;Games</a></div>
<div class="article-subtitle">Taking on the Role of an Evil Game Designer</div>		</header>
	
	    <script>
$(function() {
    $('.toggle').each(function(index) {
        var toggler = $('<div style="margin: 8px 0; background-color: #E3E0FF; cursor: pointer; padding: 8px;">Toggle iframe</div>');
        toggler.insertBefore($(this));
        toggler.click(function() {
            var elt = $(this).next('.toggle');
            var newElt = $("<iframe></iframe>")
            Array.prototype.slice.call(elt.get(0).attributes).forEach(function(a) {
                newElt.attr(a.name, a.value);
            });
            if (!$(this).hasClass('toggled')) {
                elt.append(newElt);
                $(this).addClass('toggled');
            } else {
                elt.html('');
                $(this).removeClass('toggled');
            }
        });
    });
});
</script>

<p>I have always had a sort of a love-hate relationship with <a href="https://www.jesperjuul.net/text/swapadjacent/">Match 3 games</a>. On the one hand, they offer some easy way to pass a couple of minutes of casual gaming on the bus or elsewhere, but they also oftentimes feel like being arbitrarily easy or difficult as the levels progress. Especially when we&#8217;re talking about mobile versions of the game, the difficulty jumps seem to be almost purposefully defined, in order to get the player to spend money on in-game&nbsp;upgrades.</p>
<p><img alt="There's probably no one with a smart phone who hasn't played this at some point" src="/images/2020/candy1.jpg"></p>
<p>All of this should come as no surprise. Of course game designers are going to overwhelm you with flashy sounds and congratulatory messages (you&#8217;re doing so well!) at first before stepping on the brakes and maybe offering you an exclusive one time discount (only 1 dollar for 5 more moves; only 3 dollars for 10 extra&nbsp;bombs).</p>
<p>What I wanted to play around with a bit here, however, comes from the feeling that these incentives mentioned above not only seem to come at purposefully crafted moments, but also seem to incorporate a dynamic aspect as well. It&#8217;s one thing for a designer to determine that levels 1 to 10 will gradually ramp up the difficulty, before really making things hard in level 11. Whilst still being very unfun, you could at least appropriate some fairness to this approach as it treats all players evenly. However, this is exactly what you wouldn&#8217;t want to do when you&#8217;re a game developer aiming to maximize profits. Not only does this not take into account the spending behavior of different players (some of them might be willing to shell out way earlier, or some prefer to wait a bit longer and will be turned off by this early obstacle), it also ignores the skill level of different players. It might sound surprising, but some players are <a href="https://www.youtube.com/watch?v=6mJhL-hHHAw">obscenely good</a> at Match 3 games. They can quickly identify opportunities for combo&#8217;s, and are fast at picking a good move. Other players might be slower, don&#8217;t quickly spot moves involving more than three pieces, or might simply be playing out of boredom rather than interest, with not too much cognitive involvement (like&nbsp;myself).</p>
<p>Let&#8217;s say you&#8217;re an evil game designer. How would you design a Match 3 game to take the above into consideration. Which <a href="https://twvideo01.ubm-us.net/o1/vault/gdc2017/Presentations/Sanusi_Anisa_DarkPatternsHow.pdf">dark gameplay patterns</a> can we add on top of everything else we&#8217;re using already? We change the gameplay, of course! This is what I meant by the difficulty and offered incentives hence incorporating a dynamic aspect. I don&#8217;t know about you, but if you&#8217;ve ever played a more recent Match 3 game, have you noticed,&nbsp;perhaps:</p>
<ul>
<li>Doing very well for a couple of levels and the next level suddenly being a lot&nbsp;harder?</li>
<li>Failing a level multiple times with only a few remaining goals&nbsp;left?</li>
<li>Not playing the game for a couple of days and noticing how suddenly you&#8217;re making a lot more&nbsp;combo&#8217;s?</li>
</ul>
<p>It almost feels uncanny. I&#8217;m not claiming that any of what I&#8217;ll describe below is being done by any game at this moment. In fact, pulling this off would essentially require an always-connected game where the client requests new pieces from the server as matches are being removed from the board. On the other hand, that&#8217;s not too unreasonable of a requirement as some games might implement this anyway nowadays to prevent client-side cheating. I have not reverse engineered any games on the Play Store to take a closer look at this; it&#8217;s just a thought&nbsp;exercise.</p>
<p>So, to get back on track, we&#8217;re trying to design a Match 3 game which, in a nutshell, can be made easier or harder as the game progresses based on how well the player is doing (or any other parameter, in fact; e.g. we could also give the player a &#8220;boost&#8221; if they&#8217;ve just spend money to emphasize the feel-good&nbsp;effect).</p>
<p>Let us first define the simple rules we will be using here, which are a simplification of Match 3 games found in real life, but good enough to illustrate the&nbsp;point:</p>
<ul>
<li>The game is played on a board with <code>C</code> columns and <code>R</code> rows. Typically, <code>C</code> and <code>R</code> are equal to 8 (an 8x8&nbsp;grid)</li>
<li>Each position <code>p(c,r) → s</code> with <code>c ∈ 1..C, r ∈ 1..R, s ∈ S ⋃ {0}</code> defines the piece <code>s</code> present on each location. Note that positions can be empty, so let&#8217;s say <code>0</code> is the empty indicator. Typically, <code>|S|</code> is equal to 5, 6, or higher, depending on the difficulty of the game. We&#8217;ll use 6 pieces&nbsp;here</li>
</ul>
<p>The game itself progresses through a simple state&nbsp;machine:</p>
<div class="highlight"><pre><span></span><code><span class="nv">drop</span><span class="w"> </span>↔<span class="w"> </span><span class="nv">fill</span><span class="w"> </span>→<span class="w"> </span><span class="nv">remove</span><span class="w"> </span>→<span class="w"> </span><span class="ss">(</span><span class="nv">drop</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">wait</span><span class="ss">)</span>
</code></pre></div>

<ul>
<li><code>drop</code> moves columns of gems one row down if an empty tile is found with a non-empty tile above it, working upwards: <code>∀ c ∈ C : ∀ r ∈ R..1 : p(c,r) = 0 ∧ p(c,r-1) = 0 ⇒ (∀ m ∈ r..1 : p(c,m) := p(c,m-1)) ∧ next c</code> (this assumes that <code>p(c,r) = 0</code> for out-of-bounds&nbsp;inputs)</li>
<li><code>fill</code> inserts new gems to fill up the board in case the top row is empty: <code>∀ c ∈ C : p(c,1) = 0 ⇒ p(c,1) := getGem(c,~)</code> with <code>getGem</code> being defined later and <code>~</code> referring to any implicit arguments, such as the full board, we might&nbsp;need</li>
<li>When the board is fully filled, we check for matches to remove. This is a bit cumbersome to write down in full, so lets say that we <code>∀ c ∈ C : ∀ r ∈ R..1 : isMatched(c,r) ⇒ p(c,m) := 0</code> with <code>isMatched</code> determining if a piece is part of a match. A piece is part of a match if it is at least part of three subsequent equal piece types row or column wise. Larger matches than three are hence also allowed, e.g. a row of four equal pieces matches&nbsp;completely</li>
<li>We don&#8217;t score larger matches any differently, we just assign a point per <code>isMatched(c,r)</code> that we remove. No special gems or&nbsp;anything</li>
<li>Once this is done, we move back to <code>drop</code> this continues until nothing needs to be dropped, filled, or removed, at which point we wait for user&nbsp;input</li>
<li>User input consists of swapping to neighboring gems (row or columns wise, a <a href="https://en.wikipedia.org/wiki/Von_Neumann_neighborhood">Von Neumann neighborhood</a>) for those swaps which lead to a valid match, i.e. either of the positions is involved in a <code>isMatched</code> check for the next board after&nbsp;swapping</li>
</ul>
<p>If that sounded hard, you can also just play the game for yourself. Note that there&#8217;s one component we still need to define here, which is <code>getGem</code>. (You can press <code>r</code> to restart and <code>a</code> to make a move automatically. You might need to click inside the board first to get&nbsp;focus.)</p>
<div src="/iframes/match3/random.html"
    class="toggle" scrolling="no" frameborder="0" width="520" height="350"></div>

<p>So what&#8217;s the <code>getGem</code> definition like here? Well&#8230; it&#8217;s basically as fair as it can be. Whenever there&#8217;s an empty spot to fill up, we simply pick a random&nbsp;tile.</p>
<div class="highlight"><pre><span></span><code><span class="nx">fill</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">floor</span><span class="p">(</span><span class="nx">random</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">nrGemTypes</span><span class="p">));</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">setTile</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">tile</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>This doesn&#8217;t feel too bad, right? Some of your moves might feel unlucky &#8212; i.e. you don&#8217;t get any combo&#8217;s. Oh, at this point it&#8217;s also a good idea to define a &#8220;combo&#8221;. When you make a match, a combo happens when subsequent drops lead to more matches being made. This provides a very powerful feedback to the player, even without sounds or flashy effects (although the gems breaking up do look nice, you should admit). The fact that a simple action sets of a chain of cascading events, each with immediate reward, is one of the best dopamine rushes that you can give to a player. (Again, these are well known patterns by themselves. Though writing this, I do wonder where that cascading rush comes from, evolutionary speaking, as most things in nature are action-reaction rather than&nbsp;action-reaction-reaction-&#8230;)</p>
<p>Let me take a pause for a small intermezzo at this time, before going further. In fact, this blog post idea has been written down in my notebook for about five, if not ten years for now. This is a YouTube upload I made for a Bejeweled Blitz bot in&nbsp;2010:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/4N1iAm85eBI" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>Notice the bad recording and audio quality. Peak 2010. I won&#8217;t even mention the amazing <span class="caps">VB</span> <span class="caps">GUI</span> (I forget whether it was <span class="caps">VB</span>.<span class="caps">NET</span> or still <span class="caps">VB6</span>, but for posterior&#8217;s sake, you can also watch the <a href="https://www.youtube.com/watch?v=eG_68ZUS3Ag">development timeline</a> &#8212; even more of a side point, I&#8217;m using Notepad++ and Vista in that video, which today feel nostalgic as&nbsp;well).</p>
<p>That recording was mainly a quick effort to whip up something which was fast enough to beat my friends on Facebook (back when Facebook was hip). A couple of years later, in 2015, I did it again, picking the game HuniePop, but now approaching it from a more mathematical&nbsp;angle:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6Af2gP5bjRU" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>The mathematical angle being that the bot optimized from selecting matches which would lead to the highest <span class="caps">EV</span> (Expected Value) by assuming that removed matches would lead to fully randomized drops, like the game shown above. This worked well, and I was eager to write about it outlining the full mathematical details. Sadly, once I solve a challenge &#8220;for myself&#8221; I am eager to share it with others but also very, incredibly lazy to do so. I have an utmost respect for bloggers and even more so YouTube creators who put in the effort to not only do the coding but also the production for the stuff they put out there, but sadly, I seem to alternate between moments of pure concentration and complete laziness. The second issue was the fact that HuniePop is kind of a &#8220;risqué&#8221; game, so I didn&#8217;t want to use it as an example on how to apply expectation-maximizing optimization (as sexy as that topic is, though). I also felt Match 3 games were at the end of their lifetime, but mobile games have proven that this is not the case. Lastly, I also was heavily into hacking Flash-based (yes, Flash) give-aways around the time between 2010-2015. This was in the golden era when Flash was just-about to die out, a few freelance companies were trying to hold on, and Flash was still a viable medium to make fun throw-away games and promotions with on Facebook. It&#8217;s another topic I&#8217;d like to tell the story about some day, and another one which has been on the todo list for who knows how many years now. (Not that all the todo items are decennia old, it just indicates what my backlog looks like.) In any case, someone (another hacker, in fact) found out my schemes and used the videos I&#8217;ve mentioned before as evidence I &#8220;wasn&#8217;t to be trusted&#8221;. Fun times and again, a story for another time, but at the time it also disheartened me a bit from putting even more eyes on&nbsp;it.</p>
<p>End of&nbsp;intermezzo.</p>
<p>So now try playing this incarnation of our&nbsp;game:</p>
<div src="/iframes/match3/greedy.html"
    class="toggle" scrolling="no" frameborder="0" width="520" height="350"></div>

<p>This should feel worse after a bit of playing&#8230; right? The initial board is still filled randomly, but once you make your first move, the game is biased against you, like&nbsp;so:</p>
<div class="highlight"><pre><span></span><code><span class="nx">fill</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">correctY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">getCorrectY</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">);</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">bestTile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">floor</span><span class="p">(</span><span class="nx">random</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">nrGemTypes</span><span class="p">));</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">bestMoves</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">;</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">tileIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="nx">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">tile</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">nrGemTypes</span><span class="p">;</span><span class="w"> </span><span class="nx">tile</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="nx">tileIdx</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">tile</span><span class="p">);</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">tileIdx</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">tileIdx</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">floor</span><span class="p">(</span><span class="nx">random</span><span class="p">(</span><span class="nx">tileIdx</span><span class="p">.</span><span class="nx">length</span><span class="p">)),</span><span class="w"> </span><span class="mf">1</span><span class="p">)[</span><span class="mf">0</span><span class="p">];</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">setTile</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">correctY</span><span class="p">,</span><span class="w"> </span><span class="nx">tile</span><span class="p">);</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">nrMatches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">getMatches</span><span class="p">().</span><span class="nx">length</span><span class="p">;</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">nrMoves</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">getPossibleMoves</span><span class="p">(</span><span class="kc">false</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">setTile</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">correctY</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">nrMatches</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">bestMoves</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">nrMoves</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">bestMoves</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">bestMoves</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">nrMoves</span><span class="p">;</span>
<span class="w">            </span><span class="nx">bestTile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">tile</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">setTile</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">bestTile</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Put shortly, we try to minimize the number of moves you can make, albeit in a greedy fashion. Meaning that if there are multiple columns to be filled up, we decide on a piece for the first column, and then move to the next one, without backtracking. We hence don&#8217;t guarantee that our fills will lead to a global minimum of possible moves, especially for columns where multiple spots need to be filled (this is also due to the quick and dirty JavaScript implementation and the state machine defined above, <code>fill</code> fills the top row, then moves back to <code>drop</code> and then looks whether it needs to <code>fill</code> again).</p>
<p>In any case, this is not <em>too</em> bad yet, as minimizing the number of moves does not take into account the combo-effect described above. Well, it kind of does, as moving two pieces of the same type in a row of three is technically a valid move when calculating <code>getPossibleMoves</code>, but these will be immediately&nbsp;removed.</p>
<p>Let&#8217;s take a look at these issues one by one. Starting with the greedy problem. Let&#8217;s replace this with a recursive calculation to find the outcome which leads to the global minimum of moves (again, we keep the initial board randomly filled, otherwise there won&#8217;t be any moves at all to make; it also would take a long time to calculate &#8212; the implementation is not fast to begin&nbsp;with):</p>
<div src="/iframes/match3/recursive.html"
    class="toggle" scrolling="no" frameborder="0" width="520" height="350"></div>

<p>Note that this again feels much worse to play. Now it&#8217;s not a full worst-possible recursion yet, as the global solution might still involve filling the board with pieces which do lead to an additional combo, which again would lead to a removal step and filling the board up again. We only look at the current board but not at the next boards which might arise from follow-up-removals. Doing so would be more in line with the full-recursive <span class="caps">EV</span> approach mentioned above, now using is as an <span class="caps">EV</span> minimization procedure to work against the player. However, this is not easily implemented without a system which allows for setting up a tree of game boards and searching through those, something I didn&#8217;t feel like doing in JavaScript. It&#8217;s a hard problem in any case as Match 3 games are <a href="https://arxiv.org/abs/1403.5830v1"><span class="caps">NP</span>-hard</a>.</p>
<p>We can also see what happens if we focus on combo&#8217;s in a greedy fashion, e.g. using <code>nrMatches</code> rather than <code>nrMoves</code> in the greedy code fragment above. In fact, to switch things around, let&#8217;s now go towards optimizing the highest number instead of&nbsp;lowest:</p>
<div src="/iframes/match3/maxmatches.html"
    class="toggle" scrolling="no" frameborder="0" width="520" height="350"></div>

<p>Okay, this perhaps does feel <em>too</em> good too play, but it does reveal something interesting, namely the fact that the combo-aspect is more directly related to difficulty and game-feel (in terms of &#8220;how well am I doing?&#8221;) then number of remaining moves. The reason for this being that &#8212; especially with a randomly filled initial board &#8212; their will typically be enough possible moves present so that players do not immediately feel like they&#8217;re being punished on this. We do feel that we&#8217;re not making as many long-string&nbsp;combo&#8217;s.</p>
<p>With this in mind, we can figure out a version which works greedily (which is fine), but allows to tune the amount of the game favoring&nbsp;you:</p>
<div class="highlight"><pre><span></span><code><span class="nx">fill</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">correctY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">getCorrectY</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">);</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">bestTile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">floor</span><span class="p">(</span><span class="nx">random</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">nrGemTypes</span><span class="p">));</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">bestMatches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">;</span>
<span class="w">    </span><span class="kd">var</span><span class="w"> </span><span class="nx">tileIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">var</span><span class="w"> </span><span class="nx">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">tile</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">nrGemTypes</span><span class="p">;</span><span class="w"> </span><span class="nx">tile</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="nx">tileIdx</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">tile</span><span class="p">);</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">tileIdx</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">tile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">tileIdx</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">floor</span><span class="p">(</span><span class="nx">random</span><span class="p">(</span><span class="nx">tileIdx</span><span class="p">.</span><span class="nx">length</span><span class="p">)),</span><span class="w"> </span><span class="mf">1</span><span class="p">)[</span><span class="mf">0</span><span class="p">];</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">setTile</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">correctY</span><span class="p">,</span><span class="w"> </span><span class="nx">tile</span><span class="p">);</span>
<span class="w">        </span><span class="kd">var</span><span class="w"> </span><span class="nx">nrMatches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">getMatches</span><span class="p">().</span><span class="nx">length</span><span class="p">;</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">setTile</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">correctY</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Consider better matches as long as the dice falls below a set value</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">bestMatches</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="nx">nrMatches</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nx">bestMatches</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">            </span><span class="p">(</span><span class="nx">random</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">slider</span><span class="p">.</span><span class="nx">value</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nx">bestMatches</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">nrMatches</span><span class="p">;</span>
<span class="w">            </span><span class="nx">bestTile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">tile</span><span class="p">;</span>
<span class="w">            </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">bestMatches</span><span class="p">,</span><span class="w"> </span><span class="nx">bestTile</span><span class="p">)</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">board</span><span class="p">.</span><span class="nx">setTile</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">,</span><span class="w"> </span><span class="nx">bestTile</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>There are better ways to do this, like a biased weighted random choice, but again this is enough to make the&nbsp;point:</p>
<div src="/iframes/match3/rigged.html"
    class="toggle" scrolling="no" frameborder="0" width="520" height="370"></div>

<p>Drag the slider to increase our decrease the chance of more combo&#8217;s. The higher, the better you&#8217;re&nbsp;chances.</p>
<p>To conclude, it is of course very doable to create a dynamic version of a Match 3 game which dynamically adjusts itself to make things harder or easier. This should come as no surprise of course, and a full implementation would be even better at allowing to determine which tiles should be dropped (i.e. do a full tree search) then what I did here. Obviously, the main challenge when implementing something like this is e.g. a mobile game would lie in figuring out how exactly this bias should be changed and based on which inputs. Performance over the game so far, performance over the last <em>n</em> games played, time the game was last opened, time the last purchase was made, amount spend so far? No doubt there are gacha game designers thinking about exactly these&nbsp;questions.</p>
	</article>
</div>

		</div>

		<footer class="row">
			<div class="large-12 columns">
				<hr />
				<div class="row">
					<p>Bed Against The Wall by Seppe "Macuyiko" vanden Broucke<br>
						Unless mentioned otherwise, this work is licensed under a <a
							href="http://creativecommons.org/licenses/by-sa/2.0/be/" rel="license">Creative Commons
							Attribution-Share Alike 2.0 Belgium License</a>.<br>
						Static blog engine powered by <a href="http://getpelican.com">Pelican</a>.</p>
				</div>
			</div>
		</footer>
	</div>